

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Beautiful Soup 4.2.0 文档 &mdash; Beautiful Soup 4.2.0 中文 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '4.2.0 中文',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Beautiful Soup 4.2.0 中文 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="#">Beautiful Soup 4.2.0 中文 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="beautiful-soup-4-2-0">
<h1>Beautiful Soup 4.2.0 文档<a class="headerlink" href="#beautiful-soup-4-2-0" title="Permalink to this headline">¶</a></h1>
<img alt="_images/cover.jpg" class="align-right" src="_images/cover.jpg" />
<p><a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/">BeautifulSoup</a> 是一个可以从HTML或XML文件中提取数据的python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.使用BeautifulSoup会帮助你节省数小时甚至数天的工作.</p>
<p>这篇文档介绍了BeautifulSoup4中所有主要特性,并切有小例子.让我来向你展示它适合做什么,如何工作,怎样使用,如何达到你想要的效果,和处理异常情况.</p>
<p>文档中出现的例子在python2.7和python3.2中的执行结果相同</p>
<p>你可能在寻找 <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html">BeautifulSoup3</a> 的文档,Beautiful Soup 3 目前已经停止开发,我们推荐在现在的项目中使用Beautiful Soup 4, <a class="reference external" href="http://www.baidu.com">移植到BS4</a></p>
<div class="section" id="id1">
<h2>获取帮助<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>如果你有关于BeautifulSoup的问题,可以发送邮件到 <a class="reference external" href="https://groups.google.com/forum/?fromgroups#!forum/beautifulsoup">讨论组</a> .如果你的问题包含了一段需要转换的HTML代码,确保你提的问题中附带HTML文档的在 <strong>诊断代码</strong> <a class="footnote-reference" href="#id66" id="id3">[1]</a></p>
</div>
</div>
<div class="section" id="id4">
<h1>快速开始<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h1>
<p>下面的一段HTML代码将作为我们整篇文档的解析用的例子.这是 <em>爱丽丝梦游仙境的</em> 的一段内容</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">html_doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="s">&lt;body&gt;</span>
<span class="s">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="s">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="s">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="s">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="s">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="s">and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="s">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="s">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>使用BeautifulSoup解析这段代码,能够得到一个BeautifulSoup的对象,并能按照格式化的结构输出:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c"># &lt;html&gt;</span>
<span class="c">#  &lt;head&gt;</span>
<span class="c">#   &lt;title&gt;</span>
<span class="c">#    The Dormouse&#39;s story</span>
<span class="c">#   &lt;/title&gt;</span>
<span class="c">#  &lt;/head&gt;</span>
<span class="c">#  &lt;body&gt;</span>
<span class="c">#   &lt;p class=&quot;title&quot;&gt;</span>
<span class="c">#    &lt;b&gt;</span>
<span class="c">#     The Dormouse&#39;s story</span>
<span class="c">#    &lt;/b&gt;</span>
<span class="c">#   &lt;/p&gt;</span>
<span class="c">#   &lt;p class=&quot;story&quot;&gt;</span>
<span class="c">#    Once upon a time there were three little sisters; and their names were</span>
<span class="c">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span>
<span class="c">#     Elsie</span>
<span class="c">#    &lt;/a&gt;</span>
<span class="c">#    ,</span>
<span class="c">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;</span>
<span class="c">#     Lacie</span>
<span class="c">#    &lt;/a&gt;</span>
<span class="c">#    and</span>
<span class="c">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link2&quot;&gt;</span>
<span class="c">#     Tillie</span>
<span class="c">#    &lt;/a&gt;</span>
<span class="c">#    ; and they lived at the bottom of a well.</span>
<span class="c">#   &lt;/p&gt;</span>
<span class="c">#   &lt;p class=&quot;story&quot;&gt;</span>
<span class="c">#    ...</span>
<span class="c">#   &lt;/p&gt;</span>
<span class="c">#  &lt;/body&gt;</span>
<span class="c"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>几个简单的浏览HTML节点的方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">title</span>
<span class="c"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">name</span>
<span class="c"># u&#39;title&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">string</span>
<span class="c"># u&#39;The Dormouse&#39;s story&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span>
<span class="c"># u&#39;head&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span>
<span class="c"># &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;class&#39;</span><span class="p">]</span>
<span class="c"># u&#39;title&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="c"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="c"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s">&quot;link3&quot;</span><span class="p">)</span>
<span class="c"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>
</pre></div>
</div>
<p>从文档中找到所有&lt;a&gt;标签的链接:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">link</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;href&#39;</span><span class="p">))</span>
    <span class="c"># http://example.com/elsie</span>
    <span class="c"># http://example.com/lacie</span>
    <span class="c"># http://example.com/tillie</span>
</pre></div>
</div>
<p>从文档中获取所有文字内容</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">get_text</span><span class="p">())</span>
<span class="c"># The Dormouse&#39;s story</span>
<span class="c">#</span>
<span class="c"># The Dormouse&#39;s story</span>
<span class="c">#</span>
<span class="c"># Once upon a time there were three little sisters; and their names were</span>
<span class="c"># Elsie,</span>
<span class="c"># Lacie and</span>
<span class="c"># Tillie;</span>
<span class="c"># and they lived at the bottom of a well.</span>
<span class="c">#</span>
<span class="c"># ...</span>
</pre></div>
</div>
<p>这是你需要的吗?别着急,还有更好用的</p>
</div>
<div class="section" id="beautiful-soup">
<h1>安装 Beautiful Soup<a class="headerlink" href="#beautiful-soup" title="Permalink to this headline">¶</a></h1>
<p>如果你用的是新版的Debain或ubuntu,那么可以通过系统包管理来安装</p>
<p><tt class="docutils literal"><span class="pre">$</span> <span class="pre">apt-get</span> <span class="pre">install</span> <span class="pre">python-bs4</span></tt></p>
<p>Beautiful Soup 4 通过PyPi发布,所以如果你无法使用系统包管理安装,那么也可以通过easy_install活pip来安装.包的名字是 <em>beautifulsoup4</em> ,这个包兼容python2和python3</p>
<p><tt class="docutils literal"><span class="pre">$</span> <span class="pre">easy_install</span> <span class="pre">beautifulsoup4</span></tt></p>
<p><tt class="docutils literal"><span class="pre">$</span> <span class="pre">pip</span> <span class="pre">install</span> <span class="pre">beautifulsoup4</span></tt></p>
<p>(在PyPi中还有一个名字是 <em>beautifulsoup的</em> 包,但那可能不是你想要的,那是 <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html">BeautifulSoup3</a> 的发布版本,因为很多项目还在使用BS3, 所以*beautifulsoup* 包依然有效,但是如果你想执行新版本的代码,那么你需要安装的包是 <em>beautifulsoup4</em>)</p>
<p>如果你没有安装 <em>easy_install</em> 或 <em>pip</em> ,那你也可以 <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/download/4.x/">下载BS4的源码</a> ,然后通过setup.py来安装.</p>
<p><tt class="docutils literal"><span class="pre">$</span> <span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></tt></p>
<p>如果上述安装方法都行不通,Beautiful Soup的发布协议允许你将BS4的代码打包在你的项目中,这样无须安装即可使用.</p>
<p>作者在Python2.7和Python3.2的版本下开发Beautiful Soup, Beautiful Soup应该在所有当前的python版本中正常工作</p>
<div class="section" id="id7">
<h2>安装完成后的问题<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>Beautiful Soup被打包成Python2版本的编码,当在Python3环境下安装时,会自动转换成python3的代码,如果你没有安装的过程,那么代码就不会被转换.</p>
<p>如果代码抛出了 <em>ImportError</em> 的异常: &#8220;No module named HTMLParser&#8221;, 这是因为你在python3版本中执行python2版本的代码.</p>
<p>如果代码抛出了 <em>ImportError</em> 的异常: &#8220;No module named html.parser&#8221;, 这是因为你在python2版本中执行python3版本的代码.</p>
<p>如果遇到上述2种情况,最好的解决方法是重新安装BeautifulSoup4.</p>
<p>如果遇到 <em>SyntaxError</em> &#8220;Invalid syntax&#8221; 在`ROOT_TAG_NAME = u&#8217;[document]&#8217;` ,需要将把BS4的python代码版本从python2转换到python3. 可以重新安装BS4:</p>
<p>$ python3 setup.py install</p>
<p>或在bs4的目录中执行python代码版本转换脚本</p>
<p>$ 2to3-3.2 -w bs4</p>
</div>
<div class="section" id="id8">
<h2>安装解析器<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>Beautiful Soup支持python标准库中的HTML解析器,还支持一些第三方的解析器,其中一个是 <a class="reference external" href="http://lxml.de/">lxml parser</a> .根据操作系统不同,可以选择下列不同的安装lxml的方法:</p>
<p>$ apt-get install python-lxml</p>
<p>$ easy_install lxml</p>
<p>$ pip install lxml</p>
<p>另一个可以选择的解析器是纯python代码的 <a class="reference external" href="http://code.google.com/p/html5lib/">html5lib parser</a> , html5lib parser的解析方式与浏览器相同,根据安装方式不同,可以选择下列方法安装:</p>
<p>$ apt-get install python-html5lib</p>
<p>$ easy_install html5lib</p>
<p>$ pip install html5lib</p>
<p>下表列出了主要的解析器,以及它们的优缺点:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="26%" />
<col width="26%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">解析器</th>
<th class="head">使用方法</th>
<th class="head">优势</th>
<th class="head">劣势</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Python’s html.parser</td>
<td><tt class="docutils literal"><span class="pre">BeautifulSoup(markup,</span>
<span class="pre">&quot;html.parser&quot;)</span></tt></td>
<td><ul class="first last simple">
<li>Batteries included</li>
<li>Decent speed</li>
<li>Lenient (as of Python
2.7.3 and 3.2.)</li>
</ul>
</td>
<td><ul class="first last simple">
<li>Not very lenient (before
Python 2.7.3 or 3.2.2)</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>lxml’s HTML parser</td>
<td><tt class="docutils literal"><span class="pre">BeautifulSoup(markup,</span>
<span class="pre">&quot;lxml&quot;)</span></tt></td>
<td><ul class="first last simple">
<li>Very fast</li>
<li>Lenient</li>
</ul>
</td>
<td><ul class="first last simple">
<li>External C dependency</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>lxml’s XML parser</td>
<td><p class="first"><tt class="docutils literal"><span class="pre">BeautifulSoup(markup,</span>
<span class="pre">[&quot;lxml&quot;,</span> <span class="pre">&quot;xml&quot;])</span></tt></p>
<p class="last"><tt class="docutils literal"><span class="pre">BeautifulSoup(markup,</span>
<span class="pre">&quot;xml&quot;)</span></tt></p>
</td>
<td><ul class="first last simple">
<li>Very fast</li>
<li>The only currently
supported XML parser</li>
</ul>
</td>
<td><ul class="first last simple">
<li>External C dependency</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>html5lib</td>
<td><tt class="docutils literal"><span class="pre">BeautifulSoup(markup,</span>
<span class="pre">&quot;html5lib&quot;)</span></tt></td>
<td><ul class="first last simple">
<li>Extremely lenient</li>
<li>Parses pages the same
way a web browser does</li>
<li>Creates valid HTML5</li>
</ul>
</td>
<td><ul class="first last simple">
<li>Very slow</li>
<li>External Python depende</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>推荐使用lxml作为解析器,因为lxml效率更高. 在python2.7.3之前的版本和python3中3.2.2之前的版本,必须安装lxml或html5lib, 因为那些python版本的标准库中内置的HTML解析方法不是很好.</p>
<p>提示: 如果一段HTML或XML文档格式不正确的话,那么在不同的解析器中返回的结果可能是不一样的,查看 <a class="reference external" href="http://www.baidu.com">Differences between parsers</a> 了解更多细节</p>
</div>
</div>
<div class="section" id="id9">
<h1>如何使用<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h1>
<p>将一段文档传入BeautifulSoup 的构造方法,就能得到一个文档的对象, 可以传入一段字符串或一个文件句柄.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>

<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&quot;index.html&quot;</span><span class="p">))</span>

<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s">&quot;&lt;html&gt;data&lt;/html&gt;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>首先,文档被转换成unicode,并且HTML的实例都被转换成unicode编码</p>
<div class="highlight-python"><pre>BeautifulSoup("Sacr&amp;eacute; bleu!")
&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Sacré bleu!&lt;/body&gt;&lt;/html&gt;</pre>
</div>
<p>然后,Beautiful Soup选择最合适的解析器来解析这段文档,如果手动指定解析器那么Beautiful Soup会选择指定的解析器来解析文档.(参考`Parsing XML &lt;<a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/#id16">http://www.crummy.com/software/BeautifulSoup/bs4/doc/#id16</a>&gt;`_ )</p>
</div>
<div class="section" id="id10">
<h1>对象的类型<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h1>
<p>Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构的python对象,所有对象都是4类对象中的一种: Tag, NavigableString, BeautifulSoup, Comment.</p>
<div class="section" id="tag">
<h2>Tag<a class="headerlink" href="#tag" title="Permalink to this headline">¶</a></h2>
<p>Tag 对象与XML或HTML原生文档中的tag内容相符</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s">&#39;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#39;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>
<span class="nb">type</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
<span class="c"># &lt;class &#39;bs4.element.Tag&#39;&gt;</span>
</pre></div>
</div>
<p>Tag有很多方法和属性,在 ` Navigating the tree` 和 <cite>Searching the tree</cite> 有详细解释.现在介绍一下tag中最重要的属性: name和attributes</p>
<div class="section" id="name">
<h3>Name<a class="headerlink" href="#name" title="Permalink to this headline">¶</a></h3>
<p>每个tag都有自己的名字,通过 .name 来获取</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tag</span><span class="o">.</span><span class="n">name</span>
<span class="c"># u&#39;b&#39;</span>
</pre></div>
</div>
<p>如果改变了tag的name,那将影响所有通过当前Beautiful Soup对象生成的HTML文档</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tag</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;blockquote&quot;</span>
<span class="n">tag</span>
<span class="c"># &lt;blockquote class=&quot;boldest&quot;&gt;Extremely bold&lt;/blockquote&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="attributes">
<h3>Attributes<a class="headerlink" href="#attributes" title="Permalink to this headline">¶</a></h3>
<p>一个tag可能有很多个属性. tag <em>&lt;b class=&#8221;boldest&#8221;&gt;</em> 有一个 <em>class</em> 的属性,值为&#8221;boldest&#8221;.tag的属性的操作方法与字典相同:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tag</span><span class="p">[</span><span class="s">&#39;class&#39;</span><span class="p">]</span>
<span class="c"># u&#39;boldest&#39;</span>
</pre></div>
</div>
<p>也可以直接&#8221;点&#8221;取属性, 比如: .attrs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tag</span><span class="o">.</span><span class="n">attrs</span>
<span class="c"># {u&#39;class&#39;: u&#39;boldest&#39;}</span>
</pre></div>
</div>
<p>tag的属性可以被添加,删除或修改. 再说一次, tag的属性操作方法与字典一样</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tag</span><span class="p">[</span><span class="s">&#39;class&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;verybold&#39;</span>
<span class="n">tag</span><span class="p">[</span><span class="s">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">tag</span>
<span class="c"># &lt;blockquote class=&quot;verybold&quot; id=&quot;1&quot;&gt;Extremely bold&lt;/blockquote&gt;</span>

<span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s">&#39;class&#39;</span><span class="p">]</span>
<span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s">&#39;id&#39;</span><span class="p">]</span>
<span class="n">tag</span>
<span class="c"># &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;</span>

<span class="n">tag</span><span class="p">[</span><span class="s">&#39;class&#39;</span><span class="p">]</span>
<span class="c"># KeyError: &#39;class&#39;</span>
<span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;class&#39;</span><span class="p">))</span>
<span class="c"># None</span>
</pre></div>
</div>
<div class="section" id="id11">
<h4>多值属性<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>HTML 4定义了一系列可以包含多个值的属性.在HTML5中移除了一些,却增加更多.最常见的多值的属性是 class (一个tag可以有多个CSS的class). 还有一些属性  rel, rev, accept-charset, headers, accesskey. 在Beautiful Soup中多值属性的返回值被定义为list(无论是否有多个值):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">css_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">css_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;class&#39;</span><span class="p">]</span>
<span class="c"># [&quot;body&quot;, &quot;strikeout&quot;]</span>

<span class="n">css_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s">&#39;&lt;p class=&quot;body&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">css_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;class&#39;</span><span class="p">]</span>
<span class="c"># [&quot;body&quot;]</span>
</pre></div>
</div>
<p>如果某个属性看起来好像有多个值,但在任何版本的HTML定义中都没有被定义为多值属性,那么Beautiful Soup会将这个属性作为字符串返回</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">id_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s">&#39;&lt;p id=&quot;my id&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">id_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;id&#39;</span><span class="p">]</span>
<span class="c"># &#39;my id&#39;</span>
</pre></div>
</div>
<p>将tag转换成字符串时,多值属性会合并为一个值</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">rel_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s">&#39;&lt;p&gt;Back to the &lt;a rel=&quot;index&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">rel_soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s">&#39;rel&#39;</span><span class="p">]</span>
<span class="c"># [&#39;index&#39;]</span>
<span class="n">rel_soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s">&#39;rel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;index&#39;</span><span class="p">,</span> <span class="s">&#39;contents&#39;</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">rel_soup</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
<span class="c"># &lt;p&gt;Back to the &lt;a rel=&quot;index contents&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;</span>
</pre></div>
</div>
<p>如果转换的文档是XML格式,那么tag中不包含多值属性</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xml_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;xml&#39;</span><span class="p">)</span>
<span class="n">xml_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;class&#39;</span><span class="p">]</span>
<span class="c"># u&#39;body strikeout&#39;</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="navigablestring">
<h2>NavigableString<a class="headerlink" href="#navigablestring" title="Permalink to this headline">¶</a></h2>
<p>字符串常被包含在tag内.Beautiful Soup用 <em>NavigableString</em> 类来包装tag中的字符串</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tag</span><span class="o">.</span><span class="n">string</span>
<span class="c"># u&#39;Extremely bold&#39;</span>
<span class="nb">type</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="c"># &lt;class &#39;bs4.element.NavigableString&#39;&gt;</span>
</pre></div>
</div>
<p>一个 <em>NavigableString</em> 字符串与python中的unicode字符串相同,并且还支持包含在 Navigating the tree 和 Searching the tree 中的一些特性. 通过unicode()方法可以直接将 <em>NavigableString</em> 对象转换成unicode字符串:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">unicode_string</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="n">unicode_string</span>
<span class="c"># u&#39;Extremely bold&#39;</span>
<span class="nb">type</span><span class="p">(</span><span class="n">unicode_string</span><span class="p">)</span>
<span class="c"># &lt;type &#39;unicode&#39;&gt;</span>
</pre></div>
</div>
<p>tag中包含的字符串不能编辑,但是可以被替换成其它的字符串,用 <em>replace_with()</em> 方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="s">&quot;No longer bold&quot;</span><span class="p">)</span>
<span class="n">tag</span>
<span class="c"># &lt;blockquote&gt;No longer bold&lt;/blockquote&gt;</span>
</pre></div>
</div>
<p><cite>NavigableString</cite> 对象支持 <cite>Navigating the tree</cite> 和 <cite>Searching the tree</cite> 中定义的大部分属性, 并非全部.尤其是,一个字符串不能包含其它内容(tag能够包含字符串或是其它tag),字符串不支持 <cite>.contents</cite> 或 <cite>.string</cite> 属性或 <cite>find()</cite> 方法.</p>
<p>如果想在Beautiful Soup之外使用 <cite>NavigableString</cite> 对象,需要调用 <cite>unicode()</cite> 方法,将该对象转换成普通的unicode字符串,否则就算Beautiful Soup已方法已经执行结束,该对象的输出也会带有实例的引用地址.这样会浪费内存.</p>
</div>
<div class="section" id="id12">
<h2>BeautifulSoup<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p><cite>BeautifulSoup</cite> 对象表示的是一个文档的整体.大部分时候,可以把它当作 <cite>Tag</cite> 对象,它支持 <cite>Navigating the tree</cite> 和 <cite>Searching the tree</cite> 中描述的大部分的方法.</p>
<p>因为 <cite>BeautifulSoup</cite> 对象并不是真正的HTML或XML的tag,所以它没有name和attribute属性.但有事查看它的 <cite>.name</cite> 属性是很方便的,所以 <cite>BeautifulSoup</cite> 对象包含了一个值为 &#8220;[document]&#8221; 的特殊属性 <cite>.name</cite></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">name</span>
<span class="c"># u&#39;[document]&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h2>注释及特殊字符串<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p><em>Tag</em> , <em>NavigableString</em> , <em>BeautifulSoup</em> 几乎覆盖了html和xml中的所有内容,但是还有一些特殊对象.容易让人担心的内容是文档的注释部分:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s">&quot;&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">comment</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span>
<span class="nb">type</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
<span class="c"># &lt;class &#39;bs4.element.Comment&#39;&gt;</span>
</pre></div>
</div>
<p><em>Comment</em> 对象是一个特殊类型的 <em>NavigableString</em> 对象:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">comment</span>
<span class="c"># u&#39;Hey, buddy. Want to buy a used parser&#39;</span>
</pre></div>
</div>
<p>但是当它出现在HTML文档中时, <em>Comment</em> 对象会使用特殊的格式输出:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c"># &lt;b&gt;</span>
<span class="c">#  &lt;!--Hey, buddy. Want to buy a used parser?--&gt;</span>
<span class="c"># &lt;/b&gt;</span>
</pre></div>
</div>
<p>Beautiful Soup中定义的其它类型都可能会出现在XML的文档中: <em>CData</em> , <em>ProcessingInstruction</em> , <em>Declaration</em> , <em>Doctype</em> .与 <em>Comment</em> 对象类似,这些类都是 <em>NavigableString</em> 的子类,只是添加了一些额外的方法的字符串独享.下面是用CDATA来替代注释的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">CData</span>
<span class="n">cdata</span> <span class="o">=</span> <span class="n">CData</span><span class="p">(</span><span class="s">&quot;A CDATA block&quot;</span><span class="p">)</span>
<span class="n">comment</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="n">cdata</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c"># &lt;b&gt;</span>
<span class="c">#  &lt;![CDATA[A CDATA block]]&gt;</span>
<span class="c"># &lt;/b&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id14">
<h1>操作文档树<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h1>
<p>还是拿&#8221;there sister&#8221;的文档来做例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">html_doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>

<span class="s">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="s">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="s">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="s">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="s">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="s">and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="s">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">)</span>
</pre></div>
</div>
<p>通过这段例子来演示怎样从文档的一段内容跳到另一段内容</p>
<div class="section" id="id15">
<h2>子节点<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h2>
<p>Tag可能包含字符串或其它的tag,这些内容都是tag的子节点.Beautiful Soup提供了许多操作和遍历子节点的属性.</p>
<p>注意: Beautiful Soup中字符串节点不支持操作自己点的属性,因为字符串没有子节点</p>
<div class="section" id="id16">
<h3>tag的名字<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>操作文档树最简单的方法就是告诉它你想获取的tag的name.如果想获取 &lt;head&gt; 标签,只要用 <em>soup.head</em> :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">head</span>
<span class="c"># &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span>
<span class="c"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
<p>这是个获取tag的小窍门,可以在文档树的tag中多次调用这个方法.下面的代码可以获取&lt;body&gt;标签中的第一个&lt;b&gt;标签:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">b</span>
<span class="c"># &lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;</span>
</pre></div>
</div>
<p>通过点取属性的方式只能获得当前名字的第一个tag:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="c"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>
</pre></div>
</div>
<p>如果想要得到所有的&lt;a&gt;标签,或是通过名字得到比一个tag更多的内容的时候,就需要用到 <cite>Searching the tree</cite> 中描述的方法,比如: find_all()</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="c"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="contents-children">
<h3>.contents 和 .children<a class="headerlink" href="#contents-children" title="Permalink to this headline">¶</a></h3>
<p>tag的 <em>.contents</em> 属性可以将tag的子节点以列表的方式输出:</p>
<div class="highlight-python"><pre>head_tag = soup.head
head_tag
# &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;

head_tag.contents
[&lt;title&gt;The Dormouse's story&lt;/title&gt;]

title_tag = head_tag.contents[0]
title_tag
# &lt;title&gt;The Dormouse's story&lt;/title&gt;
title_tag.contents
# [u'The Dormouse's story']</pre>
</div>
<p>BeautifulSoup对象本身一定会包含子节点,这说明&lt;html&gt;标签也是 BeautifulSoup 对象的子节点:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">len</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">contents</span><span class="p">)</span>
<span class="c"># 1</span>
<span class="n">soup</span><span class="o">.</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
<span class="c"># u&#39;html&#39;</span>
</pre></div>
</div>
<p>BeautifulSoup中的字符串没有 <em>.contents</em> 属性,因为字符串不能包含人和内容:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">text</span> <span class="o">=</span> <span class="n">title_tag</span><span class="o">.</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">text</span><span class="o">.</span><span class="n">contents</span>
<span class="c"># AttributeError: &#39;NavigableString&#39; object has no attribute &#39;contents&#39;</span>
</pre></div>
</div>
<p>通过tag的 <em>.children</em> 生成器,可以对tag的子节点进行循环:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">title_tag</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="c"># The Dormouse&#39;s story</span>
</pre></div>
</div>
</div>
<div class="section" id="descendants">
<h3>.descendants<a class="headerlink" href="#descendants" title="Permalink to this headline">¶</a></h3>
<p>.contents 和 .children 属性仅包含tag的直接子节点.例如,&lt;head&gt;标签有一个直接子节点&lt;title&gt;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>
</pre></div>
</div>
<p>但是&lt;title&gt;标签有一个子节点:字符串 “The Dormouse’s story”,这种情况下字符串 “The Dormouse’s story”也属于&lt;head&gt;标签的子节点. <em>.descendants</em> 属性可以对所有tag的子节点进行递归循环[5]_:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">head_tag</span><span class="o">.</span><span class="n">descendants</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="c"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
    <span class="c"># The Dormouse&#39;s story</span>
</pre></div>
</div>
<p>上面的例子中, &lt;head&gt;标签只有一个子节点,但是有2个子孙节点:&lt;head&gt;节点和&lt;head&gt;的子节点, <tt class="docutils literal"><span class="pre">BeautifulSoup</span></tt> 有一个直接子节点(&lt;html&gt;节点),却有很多子孙节点:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
<span class="c"># 1</span>
<span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">descendants</span><span class="p">))</span>
<span class="c"># 25</span>
</pre></div>
</div>
</div>
<div class="section" id="string">
<h3>.string<a class="headerlink" href="#string" title="Permalink to this headline">¶</a></h3>
<p>如果tag只有一个 <tt class="docutils literal"><span class="pre">NavigableString</span></tt> 类型子节点,那么这个tag可以使用 <tt class="docutils literal"><span class="pre">.string</span></tt> 得到子节点:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">title_tag</span><span class="o">.</span><span class="n">string</span>
<span class="c"># u&#39;The Dormouse&#39;s story&#39;</span>
</pre></div>
</div>
<p>如果一个tag仅有一个子节点,那么这个tag也可以使用 <tt class="docutils literal"><span class="pre">.string</span></tt> 方法,输出结果与当前唯一子节点的 <tt class="docutils literal"><span class="pre">.string</span></tt> 结果相同:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">head_tag</span><span class="o">.</span><span class="n">string</span>
<span class="c"># u&#39;The Dormouse&#39;s story&#39;</span>
</pre></div>
</div>
<p>如果tag包含了多个子节点,tag就无法确定 <tt class="docutils literal"><span class="pre">.string</span></tt> 方法应该调用哪个子节点的内容, <tt class="docutils literal"><span class="pre">.string</span></tt> 的输出结果是 <tt class="docutils literal"><span class="pre">None</span></tt> :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="c"># None</span>
</pre></div>
</div>
</div>
<div class="section" id="strings-stripped-strings">
<h3>.strings 和 stripped_strings<a class="headerlink" href="#strings-stripped-strings" title="Permalink to this headline">¶</a></h3>
<p>如果tag中包含多个字符串 <a class="footnote-reference" href="#id67" id="id17">[2]</a> ,可以使用 <tt class="docutils literal"><span class="pre">.strings</span></tt> 来循环获取:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">strings</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
    <span class="c"># u&quot;The Dormouse&#39;s story&quot;</span>
    <span class="c"># u&#39;\n\n&#39;</span>
    <span class="c"># u&quot;The Dormouse&#39;s story&quot;</span>
    <span class="c"># u&#39;\n\n&#39;</span>
    <span class="c"># u&#39;Once upon a time there were three little sisters; and their names were\n&#39;</span>
    <span class="c"># u&#39;Elsie&#39;</span>
    <span class="c"># u&#39;,\n&#39;</span>
    <span class="c"># u&#39;Lacie&#39;</span>
    <span class="c"># u&#39; and\n&#39;</span>
    <span class="c"># u&#39;Tillie&#39;</span>
    <span class="c"># u&#39;;\nand they lived at the bottom of a well.&#39;</span>
    <span class="c"># u&#39;\n\n&#39;</span>
    <span class="c"># u&#39;...&#39;</span>
    <span class="c"># u&#39;\n&#39;</span>
</pre></div>
</div>
<p>输出的字符串中可能包含了很多空格或空行,使用 <tt class="docutils literal"><span class="pre">.stripped_strings</span></tt> 可以去除多余空白内容:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">stripped_strings</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
    <span class="c"># u&quot;The Dormouse&#39;s story&quot;</span>
    <span class="c"># u&quot;The Dormouse&#39;s story&quot;</span>
    <span class="c"># u&#39;Once upon a time there were three little sisters; and their names were&#39;</span>
    <span class="c"># u&#39;Elsie&#39;</span>
    <span class="c"># u&#39;,&#39;</span>
    <span class="c"># u&#39;Lacie&#39;</span>
    <span class="c"># u&#39;and&#39;</span>
    <span class="c"># u&#39;Tillie&#39;</span>
    <span class="c"># u&#39;;\nand they lived at the bottom of a well.&#39;</span>
    <span class="c"># u&#39;...&#39;</span>
</pre></div>
</div>
<p>全部是空格的行会被忽略掉,段首和段末的空白会被删除</p>
</div>
</div>
<div class="section" id="id18">
<h2>父节点<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h2>
<p>继续分析文档树,每个tag或字符串都有父节点:被包含在某个tag中</p>
<div class="section" id="parent">
<h3>.parent<a class="headerlink" href="#parent" title="Permalink to this headline">¶</a></h3>
<p>通过 <tt class="docutils literal"><span class="pre">.parent</span></tt> 属性来获取某个元素的父节点.在例子“three sisters”的文档中,&lt;head&gt;标签是&lt;title&gt;标签的父节点:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">title_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">title</span>
<span class="n">title_tag</span>
<span class="c"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
<span class="n">title_tag</span><span class="o">.</span><span class="n">parent</span>
<span class="c"># &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
</pre></div>
</div>
<p>文档title的字符串也有父节点:&lt;title&gt;标签</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">title_tag</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">parent</span>
<span class="c"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
<p>文档的顶层节点比如&lt;html&gt;的父节点是 <tt class="docutils literal"><span class="pre">BeautifulSoup</span></tt> 对象:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">html_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">html</span>
<span class="nb">type</span><span class="p">(</span><span class="n">html_tag</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="c"># &lt;class &#39;bs4.BeautifulSoup&#39;&gt;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">BeautifulSoup</span></tt> 对象的父节点是None:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="c"># None</span>
</pre></div>
</div>
</div>
<div class="section" id="parents">
<h3>.parents<a class="headerlink" href="#parents" title="Permalink to this headline">¶</a></h3>
<p>通过元素的 <tt class="docutils literal"><span class="pre">.parents</span></tt> 属性可以递归得到元素的所有父辈节点,下面的例子使用了 <tt class="docutils literal"><span class="pre">.parent</span></tt> 方法遍历了&lt;a&gt;标签到根节点的所有节点.</p>
<div class="highlight-python"><pre>link = soup.a
link
# &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;
for parent in link.parents:
    if parent is None:
            print(parent)
                else:
                        print(parent.name)
                        # p
                        # body
                        # html
                        # [document]
                        # None</pre>
</div>
</div>
</div>
<div class="section" id="id19">
<h2>兄弟节点<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<p>看一段简单的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sibling_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s">&quot;&lt;a&gt;&lt;b&gt;text1&lt;/b&gt;&lt;c&gt;text2&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&quot;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c"># &lt;html&gt;</span>
<span class="c">#  &lt;body&gt;</span>
<span class="c">#   &lt;a&gt;</span>
<span class="c">#    &lt;b&gt;</span>
<span class="c">#     text1</span>
<span class="c">#    &lt;/b&gt;</span>
<span class="c">#    &lt;c&gt;</span>
<span class="c">#     text2</span>
<span class="c">#    &lt;/c&gt;</span>
<span class="c">#   &lt;/a&gt;</span>
<span class="c">#  &lt;/body&gt;</span>
<span class="c"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>因为&lt;b&gt;标签和&lt;c&gt;标签是同一层:他们是同一个元素的子节点,所以&lt;b&gt;和&lt;c&gt;可以被称为兄弟节点.一段文档以标准格式输出时,兄弟节点有相同的缩进级别.在代码中也可以使用这种关系</p>
<div class="section" id="next-sibling-previous-sibling">
<h3>.next_sibling 和 .previous_sibling<a class="headerlink" href="#next-sibling-previous-sibling" title="Permalink to this headline">¶</a></h3>
<p>在文档的树形结构中,可以使用 <tt class="docutils literal"><span class="pre">.next_sibling</span></tt> 和 <tt class="docutils literal"><span class="pre">.previous_sibling</span></tt> 属性来查询兄弟节点:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c"># &lt;c&gt;text2&lt;/c&gt;</span>

<span class="n">sibling_soup</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">previous_sibling</span>
<span class="c"># &lt;b&gt;text1&lt;/b&gt;</span>
</pre></div>
</div>
<p>&lt;b&gt;标签有 <tt class="docutils literal"><span class="pre">.next_sibling</span></tt> 属性,但是没有 <tt class="docutils literal"><span class="pre">.previous_sibling</span></tt> 属性,因为&lt;b&gt;标签在同级接点中是第一个.同理,&lt;c&gt;标签有 <tt class="docutils literal"><span class="pre">.previous_sibling</span></tt> 属性,却没有 <tt class="docutils literal"><span class="pre">.next_sibling</span></tt> 属性:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">previous_sibling</span><span class="p">)</span>
<span class="c"># None</span>
<span class="k">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">next_sibling</span><span class="p">)</span>
<span class="c"># None</span>
</pre></div>
</div>
<p>例子中的字符串 “text1” 和 “text2”没有兄弟节点,因为它们的父节点不同:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span>
<span class="c"># u&#39;text1&#39;</span>

<span class="k">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">next_sibling</span><span class="p">)</span>
<span class="c"># None</span>
</pre></div>
</div>
<p>实际操作中大部分的文档中的tag的 <tt class="docutils literal"><span class="pre">.next_sibling</span></tt> 和 <tt class="docutils literal"><span class="pre">.previous_sibling</span></tt> 属性通常是字符串或空白. 看看“three sisters”文档:</p>
<div class="highlight-python"><pre>&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;
&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt;
&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;</pre>
</div>
<p>如果你以为第一个&lt;a&gt;标签的 <tt class="docutils literal"><span class="pre">.next_sibling</span></tt> 结果是第二个&lt;a&gt;标签,那就错了,真是结果是第一个&lt;a&gt;标签和第二个&lt;a&gt;标签之间的顿号和换行符:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">link</span>
<span class="c"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">link</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c"># u&#39;,\n&#39;</span>
</pre></div>
</div>
<p>第二个&lt;a&gt;标签是顿号的 <tt class="docutils literal"><span class="pre">.next_sibling</span></tt> 属性:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">link</span><span class="o">.</span><span class="n">next_sibling</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="next-siblings-previous-siblings">
<h3>.next_siblings 和 .previous_siblings<a class="headerlink" href="#next-siblings-previous-siblings" title="Permalink to this headline">¶</a></h3>
<p>通过 <tt class="docutils literal"><span class="pre">.next_siblings</span></tt> 和 <tt class="docutils literal"><span class="pre">.previous_siblings</span></tt> 属性可以对当前节点的兄弟节点迭代输出:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">sibling</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">next_siblings</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sibling</span><span class="p">))</span>
    <span class="c"># u&#39;,\n&#39;</span>
    <span class="c"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span>
    <span class="c"># u&#39; and\n&#39;</span>
    <span class="c"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>
    <span class="c"># u&#39;; and they lived at the bottom of a well.&#39;</span>
    <span class="c"># None</span>

    <span class="k">for</span> <span class="n">sibling</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s">&quot;link3&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">previous_siblings</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sibling</span><span class="p">))</span>
        <span class="c"># &#39; and\n&#39;</span>
        <span class="c"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span>
        <span class="c"># u&#39;,\n&#39;</span>
        <span class="c"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>
        <span class="c"># u&#39;Once upon a time there were three little sisters; and their names were\n&#39;</span>
        <span class="c"># None</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id20">
<h2>回退和前进<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h2>
<p>看一下“three sisters” 文档:</p>
<div class="highlight-python"><pre>&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;
&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</pre>
</div>
<p>HTML解析器把这段字符串转换成一连串的事件: &#8220;打开&lt;html&gt;标签&#8221;,&#8221;打开一个&lt;head&gt;标签&#8221;,&#8221;打开一个&lt;title&gt;标签&#8221;,&#8221;添加一段字符串&#8221;,&#8221;关闭&lt;title&gt;标签&#8221;,&#8221;打开&lt;p&gt;标签&#8221;,等等.Beautiful Soup提供了重现解析器初始化过程的工具.</p>
<div class="section" id="next-element-previous-element">
<h3>.next_element 和 .previous_element<a class="headerlink" href="#next-element-previous-element" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">.next_element</span></tt> 属性指向解析过程中下一个被解析的对象(字符串或tag),结果可能与 <tt class="docutils literal"><span class="pre">.next_sibling</span></tt> 相同,但通常是不一样的.</p>
<p>这是“three sisters”文档中最后一个&lt;a&gt;标签,它的 <tt class="docutils literal"><span class="pre">.next_sibling</span></tt> 结果是一个字符串,因为当前的解析过程 <a class="footnote-reference" href="#id67" id="id21">[2]</a> 因为当前的解析过程因为遇到了&lt;a&gt;标签而终端了:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">last_a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;link3&quot;</span><span class="p">)</span>
<span class="n">last_a_tag</span>
<span class="c"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>

<span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c"># &#39;; and they lived at the bottom of a well.&#39;</span>
</pre></div>
</div>
<p>但这个&lt;a&gt;标签的 <tt class="docutils literal"><span class="pre">.next_element</span></tt> 属性结果是是&lt;a&gt;被解析之后的解析内容,不是&lt;a&gt;标签后的句子部分,而是字符串&#8221;Tillie&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_element</span>
<span class="c"># u&#39;Tillie&#39;</span>
</pre></div>
</div>
<p>这是因为在原始文档中,字符串“Tillie” 在分号前出现,解析器先进入&lt;a&gt;标签,然后是字符串“Tillie”,然后关闭&lt;/a&gt;标签,然后是分号和剩余部分.分号与&lt;a&gt;标签在同一层级,但是字符串“Tillie”会被先解析.</p>
<p><tt class="docutils literal"><span class="pre">.previous_element</span></tt> 属性刚好与 <tt class="docutils literal"><span class="pre">.next_element</span></tt> 相反,它只想当前被解析的对象的前一个解析对象:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">last_a_tag</span><span class="o">.</span><span class="n">previous_element</span>
<span class="c"># u&#39; and\n&#39;</span>
<span class="n">last_a_tag</span><span class="o">.</span><span class="n">previous_element</span><span class="o">.</span><span class="n">next_element</span>
<span class="c"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="next-elements-previous-elements">
<h3>.next_elements 和 .previous_elements<a class="headerlink" href="#next-elements-previous-elements" title="Permalink to this headline">¶</a></h3>
<p>通过 <tt class="docutils literal"><span class="pre">.next_elements</span></tt> 和 <tt class="docutils literal"><span class="pre">.previous_elements</span></tt> 的迭代器就可以向前或向后访问文档的解析内容,就好像文档正在被解析一样:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_elements</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>
    <span class="c"># u&#39;Tillie&#39;</span>
    <span class="c"># u&#39;;\nand they lived at the bottom of a well.&#39;</span>
    <span class="c"># u&#39;\n\n&#39;</span>
    <span class="c"># &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
    <span class="c"># u&#39;...&#39;</span>
    <span class="c"># u&#39;\n&#39;</span>
    <span class="c"># None</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id22">
<h1>搜索文档树<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h1>
<p>Beautiful Soup定义了很多搜索方法,这里着重介绍2个方法: <tt class="docutils literal"><span class="pre">find()</span></tt> 和 <tt class="docutils literal"><span class="pre">find_all()</span></tt> .其它方法的参数和用法类似,请读者举一反三.</p>
<p>再以“three sisters”文档作为例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">html_doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>

<span class="s">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="s">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="s">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="s">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="s">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="s">and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="s">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 <tt class="docutils literal"><span class="pre">find_all()</span></tt> 类似的方法可以定位到想要查找的文档内容</p>
<div class="section" id="id23">
<h2>过滤器<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h2>
<p>介绍 <tt class="docutils literal"><span class="pre">find_all()</span></tt> 方法前,先介绍一下过滤器的类型 <a class="footnote-reference" href="#id68" id="id24">[3]</a> ,这些过滤器贯穿整个搜索的API.过滤器可以被用在tag的name中,节点的属性中,字符串中或他们的混合中</p>
<div class="section" id="id25">
<h3>字符串<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h3>
<p>最简单的过滤器是字符串.在搜索方法中传入一个字符串参数,Beautiful Soup会查找与字符串完整匹配的内容,下面的例子用于查找文档中所有的&lt;b&gt;标签:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">)</span>
<span class="c"># [&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;]</span>
</pre></div>
</div>
<p>如果传入字节码参数,Beautiful Soup会当作UTF-8编码,可以传入一段Unicode 编码来避免Beautiful Soup解析编码出错</p>
</div>
<div class="section" id="id26">
<h3>正则表达式<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h3>
<p>如果传入正则表达式作为参数,Beautiful Soup会通过正则表达式的 <tt class="docutils literal"><span class="pre">match()</span></tt> 来匹配内容.下面例子中找出所有以b开头的标签,这表示&lt;body&gt;和&lt;b&gt;标签都应该被找到:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">re</span>
<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;^b&quot;</span><span class="p">)):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="c"># body</span>
    <span class="c"># b</span>
</pre></div>
</div>
<p>下面代码找出所有包含h的标签:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;t&quot;</span><span class="p">)):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="c"># html</span>
    <span class="c"># title</span>
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h3>列表<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<p>如果传入列表参数,Beautiful Soup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有&lt;a&gt;标签和&lt;b&gt;标签:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">([</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">])</span>
<span class="c"># [&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;,</span>
<span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="true">
<h3>True<a class="headerlink" href="#true" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">True</span></tt> 可以匹配任何值,下面代码查找到所有的tag,但是没有查找到字符串</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="c"># html</span>
    <span class="c"># head</span>
    <span class="c"># title</span>
    <span class="c"># body</span>
    <span class="c"># p</span>
    <span class="c"># b</span>
    <span class="c"># p</span>
    <span class="c"># a</span>
    <span class="c"># a</span>
    <span class="c"># a</span>
    <span class="c"># p</span>
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h3>方法<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<p>如果没有合适过滤器,那么还可以定义一个方法,方法只接受一个元素参数 <a class="footnote-reference" href="#id69" id="id29">[4]</a> ,如果这个方法返回 <tt class="docutils literal"><span class="pre">True</span></tt> 表示当前元素匹配并且被找到,如果不是则放回 <tt class="docutils literal"><span class="pre">False</span></tt></p>
<p>下面方法校验了当前元素,如果包含 <tt class="docutils literal"><span class="pre">class</span></tt> 属性却不包含 <tt class="docutils literal"><span class="pre">id</span></tt> 属性,那么将返回 <tt class="docutils literal"><span class="pre">True</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">has_class_but_no_id</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tag</span><span class="o">.</span><span class="n">has_attr</span><span class="p">(</span><span class="s">&#39;class&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tag</span><span class="o">.</span><span class="n">has_attr</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>将这个方法作为参数传入 <tt class="docutils literal"><span class="pre">find_all()</span></tt> 方法,将得到所有&lt;p&gt;标签:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">has_class_but_no_id</span><span class="p">)</span>
<span class="c"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;,</span>
<span class="c">#  &lt;p class=&quot;story&quot;&gt;Once upon a time there were...&lt;/p&gt;,</span>
<span class="c">#  &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]</span>
</pre></div>
</div>
<p>返回结果中只有&lt;p&gt;标签没有&lt;a&gt;标签,因为&lt;a&gt;标签还定义了&#8221;id&#8221;,没有返回&lt;html&gt;和&lt;head&gt;,因为&lt;html&gt;和&lt;head&gt;中没有定义&#8221;class&#8221;属性.</p>
<p>下面代码找到所有被文字包含的节点内容:</p>
<div class="highlight-python"><pre>from bs4 import NavigableString
def surrounded_by_strings(tag):
    return (isinstance(tag.next_element, NavigableString)
                and isinstance(tag.previous_element, NavigableString))

                for tag in soup.find_all(surrounded_by_strings):
                    print tag.name
                    # p
                    # a
                    # a
                    # a
                    # p</pre>
</div>
<p>现在来了解一下搜索方法的细节</p>
</div>
</div>
<div class="section" id="find-all">
<h2>find_all()<a class="headerlink" href="#find-all" title="Permalink to this headline">¶</a></h2>
<p>参数: find_all(name, attrs, recursive, text, limit,**kwargs)</p>
<p><tt class="docutils literal"><span class="pre">find_all()</span></tt> 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件.这里有几个例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&quot;title&quot;</span><span class="p">)</span>
<span class="c"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">,</span> <span class="s">&quot;title&quot;</span><span class="p">)</span>
<span class="c"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span>
<span class="c"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s">&quot;link2&quot;</span><span class="p">)</span>
<span class="c"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;sisters&quot;</span><span class="p">))</span>
<span class="c"># u&#39;Once upon a time there were three little sisters; and their names were\n&#39;</span>
</pre></div>
</div>
<p>有几个方法是刚出现的,参数中的 <tt class="docutils literal"><span class="pre">text</span></tt> 和 <tt class="docutils literal"><span class="pre">id</span></tt> 是什么含义? 为什么 <tt class="docutils literal"><span class="pre">find_all(&quot;p&quot;,</span> <span class="pre">&quot;title&quot;)</span></tt> 返回的是CSS Class为&#8221;title&#8221;的&lt;p&gt;标签? 我们来仔细看一下 <tt class="docutils literal"><span class="pre">find_all()</span></tt> 的参数</p>
<div class="section" id="id30">
<h3>name 参数<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h3>
<p>Beautiful Soup的 <tt class="docutils literal"><span class="pre">name</span></tt> 参数可以查找所有名字为 <tt class="docutils literal"><span class="pre">name</span></tt> 的tag,字符串对象会被自动忽略掉.</p>
<p>简单的用法如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&quot;title&quot;</span><span class="p">)</span>
<span class="c"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>
</pre></div>
</div>
<p>重申: 搜索 <tt class="docutils literal"><span class="pre">name</span></tt> 参数的值可以使任一类型的 <a class="reference internal" href="#id23">过滤器</a> ,字符窜,正则表达式,列表,方法或是 <tt class="docutils literal"><span class="pre">True</span></tt> .</p>
</div>
<div class="section" id="keyword">
<h3>keyword 参数<a class="headerlink" href="#keyword" title="Permalink to this headline">¶</a></h3>
<p>如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作</p>
</div>
<div class="section" id="css">
<h3>按CSS搜索<a class="headerlink" href="#css" title="Permalink to this headline">¶</a></h3>
<p>按照CSS类名搜索tag的功能非常实用,但标识CSS类名的关键字 <tt class="docutils literal"><span class="pre">class</span></tt> 在python中是保留字,使用 <tt class="docutils literal"><span class="pre">class</span></tt> 做参数会导致语法错误.从Beautiful Soup的4.1.1版本开始,可以通过 <tt class="docutils literal"><span class="pre">class_</span></tt> 参数搜索有指定类名的tag:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s">&quot;sister&quot;</span><span class="p">)</span>
<span class="c"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">class_</span></tt> 参数同样接受不同类型的 <tt class="docutils literal"><span class="pre">过滤器</span></tt> ,字符串,正则表达式,方法或 <tt class="docutils literal"><span class="pre">True</span></tt> :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">class_</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;itl&quot;</span><span class="p">))</span>
<span class="c"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;]</span>

<span class="k">def</span> <span class="nf">has_six_characters</span><span class="p">(</span><span class="n">css_class</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">css_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">css_class</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>

    <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">class_</span><span class="o">=</span><span class="n">has_six_characters</span><span class="p">)</span>
    <span class="c"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
    <span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
    <span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>tag的 <tt class="docutils literal"><span class="pre">class</span></tt> 属性是 <a class="reference internal" href="#id11">多值属性</a> .按照CSS类名搜索tag时,可以分别搜索tag中的多个CSS类名:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">css_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s">&quot;strikeout&quot;</span><span class="p">)</span>
<span class="c"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span>

<span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s">&quot;body&quot;</span><span class="p">)</span>
<span class="c"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span>
</pre></div>
</div>
<p>搜索 <tt class="docutils literal"><span class="pre">class</span></tt> 属性时也可以通过CSS值完全匹配:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s">&quot;body strikeout&quot;</span><span class="p">)</span>
<span class="c"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span>
</pre></div>
</div>
<p>完全匹配 <tt class="docutils literal"><span class="pre">class</span></tt> 的值时,如果CSS类名的数序与实际不符,将搜索不到结果:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;class&quot;</span><span class="p">:</span> <span class="s">&quot;sister&quot;</span><span class="p">})</span>
<span class="c"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="text">
<h3><tt class="docutils literal"><span class="pre">text</span></tt> 参数<a class="headerlink" href="#text" title="Permalink to this headline">¶</a></h3>
<p>通过 <tt class="docutils literal"><span class="pre">text</span></tt> 参数可以搜搜文档中的字符串内容.与 <tt class="docutils literal"><span class="pre">name</span></tt> 参数的可选值一样, <tt class="docutils literal"><span class="pre">text</span></tt> 参数接受 <a class="reference internal" href="#id25">字符串</a> , <a class="reference internal" href="#id26">正则表达式</a> , <a class="reference internal" href="#id27">列表</a>, <a class="reference internal" href="#true">True</a> . 看例子:</p>
<div class="highlight-python"><pre>soup.find_all(text="Elsie")
# [u'Elsie']

soup.find_all(text=["Tillie", "Elsie", "Lacie"])
# [u'Elsie', u'Lacie', u'Tillie']

soup.find_all(text=re.compile("Dormouse"))
[u"The Dormouse's story", u"The Dormouse's story"]

def is_the_only_string_within_a_tag(s):
    ""Return True if this string is the only child of its parent tag.""
        return (s == s.parent.string)

        soup.find_all(text=is_the_only_string_within_a_tag)
        # [u"The Dormouse's story", u"The Dormouse's story", u'Elsie', u'Lacie', u'Tillie', u'...']</pre>
</div>
<p>虽然 <tt class="docutils literal"><span class="pre">text</span></tt> 参数用于搜索字符串,还可以与其它参数混合使用来过滤tag.Beautiful Soup会找到 <tt class="docutils literal"><span class="pre">.string</span></tt> 方法与 <tt class="docutils literal"><span class="pre">text</span></tt> 参数值相符的tag.下面代码用来搜索内容里面包含“Elsie”的&lt;a&gt;标签:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&quot;Elsie&quot;</span><span class="p">)</span>
<span class="c"># [&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="limit">
<h3><tt class="docutils literal"><span class="pre">limit</span></tt> 参数<a class="headerlink" href="#limit" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="recursive">
<h3><tt class="docutils literal"><span class="pre">recursive</span></tt> 参数<a class="headerlink" href="#recursive" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="find-all-tag">
<h2>像调用 <tt class="docutils literal"><span class="pre">find_all()</span></tt> 一样调用tag<a class="headerlink" href="#find-all-tag" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">find_all()</span></tt> 几乎是Beautiful Soup中最常用的搜索方法,所以我们定义了 <tt class="docutils literal"><span class="pre">find_all()</span></tt> 的简写方法. 一个 <tt class="docutils literal"><span class="pre">BeautifulSoup</span></tt> 对象和 <tt class="docutils literal"><span class="pre">tag</span></tt> 对象可以被当作一个方法来看待,这个方法的执行结果与调用这个对象的 <tt class="docutils literal"><span class="pre">find_all()</span></tt> 方法相同,下面两行代码是等价的:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>这两行代码也是等价的:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="find">
<h2>find()<a class="headerlink" href="#find" title="Permalink to this headline">¶</a></h2>
<p>find( <a class="reference internal" href="#id30">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#text">text</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
<p><tt class="docutils literal"><span class="pre">find_all()</span></tt> 方法将返回文档中符合条件的所有tag,尽管有时候我们只想得到一个tag结果.假如你知道文档中只有一个&lt;body&gt;标签,那么使用 <tt class="docutils literal"><span class="pre">find_all()</span></tt> 方法来查找&lt;body&gt;标签是不划算的, <tt class="docutils literal"><span class="pre">find()</span></tt> 方法仅返回一个值.</p>
<p><tt class="docutils literal"><span class="pre">find_all()</span></tt> 方法没有找到目标是返回空列表, <tt class="docutils literal"><span class="pre">find()</span></tt> 方法找不到目标时,返回 <tt class="docutils literal"><span class="pre">None</span></tt> .</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;nosuchtag&quot;</span><span class="p">))</span>
<span class="c"># None</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">soup.head.title</span></tt> 是 <a class="reference internal" href="#id16">tag的名字</a> 方法的简写.这个简写的原理就是多次调用当前tag的 <tt class="docutils literal"><span class="pre">find()</span></tt> 方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">title</span>
<span class="c"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;head&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;title&quot;</span><span class="p">)</span>
<span class="c"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="find-parents-find-parent">
<h2>find_parents() 和 find_parent()<a class="headerlink" href="#find-parents-find-parent" title="Permalink to this headline">¶</a></h2>
<p>find_parents( <a class="reference internal" href="#id30">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#text">text</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
<p>find_parent( <a class="reference internal" href="#id30">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#text">text</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
<p>我们已经用了很大篇幅来介绍 <tt class="docutils literal"><span class="pre">find_all()</span></tt> 和 <tt class="docutils literal"><span class="pre">find()</span></tt> 方法,Beautiful Soup中还有10个用于搜索的API.它们中的五个用的是与 <tt class="docutils literal"><span class="pre">find_all()</span></tt> 相同的搜索参数,另外5个与 <tt class="docutils literal"><span class="pre">find()</span></tt> 方法的搜索参数类似.区别仅是它们搜索文档的不同部分.</p>
<p>记住: <tt class="docutils literal"><span class="pre">find_all()</span></tt> 和 <tt class="docutils literal"><span class="pre">find()</span></tt> 只搜索当前节点的所有子节点,孙子节点等. <tt class="docutils literal"><span class="pre">find_parents()</span></tt> 和 <tt class="docutils literal"><span class="pre">find_parent()</span></tt> 用来搜索当前节点的父辈节点,搜索方法与普通tag的搜索方法相同,搜索文档搜索文档包含的内容. 我们从一个文档中的一个自己点开始:</p>
<div class="highlight-python"><pre>a_string = soup.find(text="Lacie")
a_string
# u'Lacie'

a_string.find_parents("a")
# [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]

a_string.find_parent("p")
# &lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were
#  &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,
#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt; and
#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;;
#  and they lived at the bottom of a well.&lt;/p&gt;

a_string.find_parents("p", class="title")
# []</pre>
</div>
</div>
<div class="section" id="find-next-siblings-find-next-sibling">
<h2>find_next_siblings() 合 find_next_sibling()<a class="headerlink" href="#find-next-siblings-find-next-sibling" title="Permalink to this headline">¶</a></h2>
<p>find_next_siblings( <a class="reference internal" href="#id30">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#text">text</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
<p>find_next_sibling( <a class="reference internal" href="#id30">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#text">text</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
<p>这2个方法通过 <a class="reference internal" href="#next-siblings-previous-siblings">.next_siblings</a> 属性对当tag的所有后面 <a class="footnote-reference" href="#id70" id="id31">[5]</a> 兄弟tag节点进行迭代, <tt class="docutils literal"><span class="pre">find_next_siblings()</span></tt> 方法返回所有符合条件的后面的兄弟节点, <tt class="docutils literal"><span class="pre">find_next_sibling()</span></tt> 只返回符合条件的后面的第一个tag节点.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">first_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">first_link</span>
<span class="c"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_next_siblings</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span>
<span class="c"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">first_story_paragraph</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">,</span> <span class="s">&quot;story&quot;</span><span class="p">)</span>
<span class="n">first_story_paragraph</span><span class="o">.</span><span class="n">find_next_sibling</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">)</span>
<span class="c"># &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="find-previous-siblings-find-previous-sibling">
<h2>find_previous_siblings() 和 find_previous_sibling()<a class="headerlink" href="#find-previous-siblings-find-previous-sibling" title="Permalink to this headline">¶</a></h2>
<p>find_previous_siblings( <a class="reference internal" href="#id30">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#text">text</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
<p>find_previous_sibling( <a class="reference internal" href="#id30">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#text">text</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
<p>这2个方法通过 <a class="reference internal" href="#next-siblings-previous-siblings">.previous_siblings</a> 属性对当前tag的前面 <a class="footnote-reference" href="#id70" id="id32">[5]</a> 的兄弟tag节点进行迭代, <tt class="docutils literal"><span class="pre">find_previous_siblings()</span></tt> 方法返回所有符合条件的前面的兄弟节点, <tt class="docutils literal"><span class="pre">find_previous_sibling()</span></tt> 方法返回第一个符合条件的前面的兄弟节点:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">last_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;link3&quot;</span><span class="p">)</span>
<span class="n">last_link</span>
<span class="c"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>

<span class="n">last_link</span><span class="o">.</span><span class="n">find_previous_siblings</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span>
<span class="c"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>

<span class="n">first_story_paragraph</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">,</span> <span class="s">&quot;story&quot;</span><span class="p">)</span>
<span class="n">first_story_paragraph</span><span class="o">.</span><span class="n">find_previous_sibling</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">)</span>
<span class="c"># &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="find-all-next-find-next">
<h2>find_all_next() 和 find_next()<a class="headerlink" href="#find-all-next-find-next" title="Permalink to this headline">¶</a></h2>
<p>find_all_next( <a class="reference internal" href="#id30">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#text">text</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
<p>find_next( <a class="reference internal" href="#id30">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#text">text</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
<p>这2个方法通过 <a class="reference internal" href="#next-elements-previous-elements">.next_elements</a> 属性对当前节点后面的tag和字符串进行迭代, <tt class="docutils literal"><span class="pre">find_all_next()</span></tt> 方法返回所有符合条件的节点, <tt class="docutils literal"><span class="pre">find_next()</span></tt> 方法返回第一个符合条件的节点:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">first_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">first_link</span>
<span class="c"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_all_next</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c"># [u&#39;Elsie&#39;, u&#39;,\n&#39;, u&#39;Lacie&#39;, u&#39; and\n&#39;, u&#39;Tillie&#39;,</span>
<span class="c">#  u&#39;;\nand they lived at the bottom of a well.&#39;, u&#39;\n\n&#39;, u&#39;...&#39;, u&#39;\n&#39;]</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_next</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">)</span>
<span class="c"># &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
</pre></div>
</div>
<p>第一个例子中,字符串 “Elsie”也被显示出来,尽管它被包含在我们开始查找的&lt;a&gt;标签的里面.第二个例子中,最后一个&lt;p&gt;标签也被显示出来,尽管它与我们开始查找位置的&lt;a&gt;标签不属于同一部分.例子中,搜索的重点是要匹配过滤器的条件,并且在文档中出现的顺序而不是开始查找的元素的位置.</p>
</div>
<div class="section" id="find-all-previous-find-previous">
<h2>find_all_previous() 和 find_previous()<a class="headerlink" href="#find-all-previous-find-previous" title="Permalink to this headline">¶</a></h2>
<p>find_all_previous( <a class="reference internal" href="#id30">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#text">text</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
<p>find_previous( <a class="reference internal" href="#id30">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#text">text</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
<p>这2个方法通过 <a class="reference internal" href="#next-elements-previous-elements">.previous_elements</a> 属性对当前节点前面的tag和字符串进行迭代, <tt class="docutils literal"><span class="pre">find_all_previous()</span></tt> 方法返回所有符合条件的节点, <tt class="docutils literal"><span class="pre">find_previous()</span></tt> 方法返回第一个符合条件的节点.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">first_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">first_link</span>
<span class="c"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_all_previous</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">)</span>
<span class="c"># [&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; ...&lt;/p&gt;,</span>
<span class="c">#  &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;]</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_previous</span><span class="p">(</span><span class="s">&quot;title&quot;</span><span class="p">)</span>
<span class="c"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h2>CSS选择器<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h2>
</div>
</div>
<div class="section" id="id34">
<h1>修改文档树<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id35">
<h2>修改tag的名称和属性<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id36">
<h2>修改 .string<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="append">
<h2>append()<a class="headerlink" href="#append" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beautifulsoup-new-string-new-tag">
<h2>BeautifulSoup.new_string() 和 .new_tag()<a class="headerlink" href="#beautifulsoup-new-string-new-tag" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="insert">
<h2>insert()<a class="headerlink" href="#insert" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="insert-before-insert-after">
<h2>insert_before() 和 insert_after()<a class="headerlink" href="#insert-before-insert-after" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="clear">
<h2>clear()<a class="headerlink" href="#clear" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="extract">
<h2>extract()<a class="headerlink" href="#extract" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="decompose">
<h2>decompose()<a class="headerlink" href="#decompose" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="replace-with">
<h2>replace_with()<a class="headerlink" href="#replace-with" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="wrap">
<h2>wrap()<a class="headerlink" href="#wrap" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="unwrap">
<h2>unwrap()<a class="headerlink" href="#unwrap" title="Permalink to this headline">¶</a></h2>
</div>
</div>
<div class="section" id="id37">
<h1>输出<a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id38">
<h2>格式化输出<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id39">
<h2>压缩输出<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id40">
<h2>输出格式<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="get-text">
<h2>get_text()<a class="headerlink" href="#get-text" title="Permalink to this headline">¶</a></h2>
</div>
</div>
<div class="section" id="id41">
<h1>指定文档解析器<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id42">
<h2>解析器之间的区别<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h2>
</div>
</div>
<div class="section" id="id43">
<h1>编码<a class="headerlink" href="#id43" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id44">
<h2>输出编码<a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="unicode">
<h2>unicode, 靠!<a class="headerlink" href="#unicode" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id45">
<h2>输出的编码<a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id46">
<h2>矛盾的编码<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h2>
</div>
</div>
<div class="section" id="id47">
<h1>转换部分文档<a class="headerlink" href="#id47" title="Permalink to this headline">¶</a></h1>
<div class="section" id="soupstrainer">
<h2>SoupStrainer<a class="headerlink" href="#soupstrainer" title="Permalink to this headline">¶</a></h2>
</div>
</div>
<div class="section" id="id48">
<h1>常见问题<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h1>
<div class="section" id="diagnose">
<h2>diagnose()<a class="headerlink" href="#diagnose" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id49">
<h2>文档解析错误<a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id50">
<h2>版本错误<a class="headerlink" href="#id50" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="xml">
<h2>解析XML<a class="headerlink" href="#xml" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id51">
<h2>解析器的错误<a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id52">
<h2>杂项错误<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id53">
<h2>如何提高效率<a class="headerlink" href="#id53" title="Permalink to this headline">¶</a></h2>
</div>
</div>
<div class="section" id="beautiful-soup-3">
<h1>Beautiful Soup 3<a class="headerlink" href="#beautiful-soup-3" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id54">
<h2>迁移到BS4<a class="headerlink" href="#id54" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id55">
<h3>需要的解析器<a class="headerlink" href="#id55" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="id56">
<h3>方法的名字<a class="headerlink" href="#id56" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="id57">
<h3>生成器<a class="headerlink" href="#id57" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="id58">
<h3>XML<a class="headerlink" href="#id58" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="id59">
<h3>实例<a class="headerlink" href="#id59" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="id60">
<h3>迁移杂项<a class="headerlink" href="#id60" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://www.python.org">Python</a></p>
<p><a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.zh.html">BeautifulSoup3 文档</a></p>
</div>
</div>
</div>
<div class="section" id="id65">
<h1>注释文档<a class="headerlink" href="#id65" title="Permalink to this headline">¶</a></h1>
<table class="docutils footnote" frame="void" id="id66" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>BeautifulSoup的googl讨论组不是很活跃,可能是因为库已经比较完善了吧</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id67" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id17">1</a>, <a class="fn-backref" href="#id21">2</a>)</em> 文档被解析成树形结构,所以下一步解析过程应该是当前节点的子节点</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id68" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id24">[3]</a></td><td>过滤器只能作为搜索文档的参数,或者说应该叫参数类型更为贴切,原文中用了 <tt class="docutils literal"><span class="pre">filter</span></tt> 因此翻译为过滤器</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id69" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id29">[4]</a></td><td>元素参数,HTML文档中的一个tag节点,不能是文本节点</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id70" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id31">1</a>, <a class="fn-backref" href="#id32">2</a>)</em> 采用先序遍历方式</td></tr>
</tbody>
</table>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Beautiful Soup 4.2.0 文档</a><ul>
<li><a class="reference internal" href="#id1">获取帮助</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">快速开始</a></li>
<li><a class="reference internal" href="#beautiful-soup">安装 Beautiful Soup</a><ul>
<li><a class="reference internal" href="#id7">安装完成后的问题</a></li>
<li><a class="reference internal" href="#id8">安装解析器</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9">如何使用</a></li>
<li><a class="reference internal" href="#id10">对象的类型</a><ul>
<li><a class="reference internal" href="#tag">Tag</a><ul>
<li><a class="reference internal" href="#name">Name</a></li>
<li><a class="reference internal" href="#attributes">Attributes</a><ul>
<li><a class="reference internal" href="#id11">多值属性</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#navigablestring">NavigableString</a></li>
<li><a class="reference internal" href="#id12">BeautifulSoup</a></li>
<li><a class="reference internal" href="#id13">注释及特殊字符串</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id14">操作文档树</a><ul>
<li><a class="reference internal" href="#id15">子节点</a><ul>
<li><a class="reference internal" href="#id16">tag的名字</a></li>
<li><a class="reference internal" href="#contents-children">.contents 和 .children</a></li>
<li><a class="reference internal" href="#descendants">.descendants</a></li>
<li><a class="reference internal" href="#string">.string</a></li>
<li><a class="reference internal" href="#strings-stripped-strings">.strings 和 stripped_strings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id18">父节点</a><ul>
<li><a class="reference internal" href="#parent">.parent</a></li>
<li><a class="reference internal" href="#parents">.parents</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id19">兄弟节点</a><ul>
<li><a class="reference internal" href="#next-sibling-previous-sibling">.next_sibling 和 .previous_sibling</a></li>
<li><a class="reference internal" href="#next-siblings-previous-siblings">.next_siblings 和 .previous_siblings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id20">回退和前进</a><ul>
<li><a class="reference internal" href="#next-element-previous-element">.next_element 和 .previous_element</a></li>
<li><a class="reference internal" href="#next-elements-previous-elements">.next_elements 和 .previous_elements</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id22">搜索文档树</a><ul>
<li><a class="reference internal" href="#id23">过滤器</a><ul>
<li><a class="reference internal" href="#id25">字符串</a></li>
<li><a class="reference internal" href="#id26">正则表达式</a></li>
<li><a class="reference internal" href="#id27">列表</a></li>
<li><a class="reference internal" href="#true">True</a></li>
<li><a class="reference internal" href="#id28">方法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#find-all">find_all()</a><ul>
<li><a class="reference internal" href="#id30">name 参数</a></li>
<li><a class="reference internal" href="#keyword">keyword 参数</a></li>
<li><a class="reference internal" href="#css">按CSS搜索</a></li>
<li><a class="reference internal" href="#text"><tt class="docutils literal"><span class="pre">text</span></tt> 参数</a></li>
<li><a class="reference internal" href="#limit"><tt class="docutils literal"><span class="pre">limit</span></tt> 参数</a></li>
<li><a class="reference internal" href="#recursive"><tt class="docutils literal"><span class="pre">recursive</span></tt> 参数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#find-all-tag">像调用 <tt class="docutils literal"><span class="pre">find_all()</span></tt> 一样调用tag</a></li>
<li><a class="reference internal" href="#find">find()</a></li>
<li><a class="reference internal" href="#find-parents-find-parent">find_parents() 和 find_parent()</a></li>
<li><a class="reference internal" href="#find-next-siblings-find-next-sibling">find_next_siblings() 合 find_next_sibling()</a></li>
<li><a class="reference internal" href="#find-previous-siblings-find-previous-sibling">find_previous_siblings() 和 find_previous_sibling()</a></li>
<li><a class="reference internal" href="#find-all-next-find-next">find_all_next() 和 find_next()</a></li>
<li><a class="reference internal" href="#find-all-previous-find-previous">find_all_previous() 和 find_previous()</a></li>
<li><a class="reference internal" href="#id33">CSS选择器</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id34">修改文档树</a><ul>
<li><a class="reference internal" href="#id35">修改tag的名称和属性</a></li>
<li><a class="reference internal" href="#id36">修改 .string</a></li>
<li><a class="reference internal" href="#append">append()</a></li>
<li><a class="reference internal" href="#beautifulsoup-new-string-new-tag">BeautifulSoup.new_string() 和 .new_tag()</a></li>
<li><a class="reference internal" href="#insert">insert()</a></li>
<li><a class="reference internal" href="#insert-before-insert-after">insert_before() 和 insert_after()</a></li>
<li><a class="reference internal" href="#clear">clear()</a></li>
<li><a class="reference internal" href="#extract">extract()</a></li>
<li><a class="reference internal" href="#decompose">decompose()</a></li>
<li><a class="reference internal" href="#replace-with">replace_with()</a></li>
<li><a class="reference internal" href="#wrap">wrap()</a></li>
<li><a class="reference internal" href="#unwrap">unwrap()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id37">输出</a><ul>
<li><a class="reference internal" href="#id38">格式化输出</a></li>
<li><a class="reference internal" href="#id39">压缩输出</a></li>
<li><a class="reference internal" href="#id40">输出格式</a></li>
<li><a class="reference internal" href="#get-text">get_text()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id41">指定文档解析器</a><ul>
<li><a class="reference internal" href="#id42">解析器之间的区别</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id43">编码</a><ul>
<li><a class="reference internal" href="#id44">输出编码</a></li>
<li><a class="reference internal" href="#unicode">unicode, 靠!</a></li>
<li><a class="reference internal" href="#id45">输出的编码</a></li>
<li><a class="reference internal" href="#id46">矛盾的编码</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id47">转换部分文档</a><ul>
<li><a class="reference internal" href="#soupstrainer">SoupStrainer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id48">常见问题</a><ul>
<li><a class="reference internal" href="#diagnose">diagnose()</a></li>
<li><a class="reference internal" href="#id49">文档解析错误</a></li>
<li><a class="reference internal" href="#id50">版本错误</a></li>
<li><a class="reference internal" href="#xml">解析XML</a></li>
<li><a class="reference internal" href="#id51">解析器的错误</a></li>
<li><a class="reference internal" href="#id52">杂项错误</a></li>
<li><a class="reference internal" href="#id53">如何提高效率</a></li>
</ul>
</li>
<li><a class="reference internal" href="#beautiful-soup-3">Beautiful Soup 3</a><ul>
<li><a class="reference internal" href="#id54">迁移到BS4</a><ul>
<li><a class="reference internal" href="#id55">需要的解析器</a></li>
<li><a class="reference internal" href="#id56">方法的名字</a></li>
<li><a class="reference internal" href="#id57">生成器</a></li>
<li><a class="reference internal" href="#id58">XML</a></li>
<li><a class="reference internal" href="#id59">实例</a></li>
<li><a class="reference internal" href="#id60">迁移杂项</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id65">注释文档</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="#">Beautiful Soup 4.2.0 中文 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, delong.wang.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>